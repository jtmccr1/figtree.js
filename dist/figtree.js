(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3"));
	else if(typeof define === 'function' && define.amd)
		define(["d3"], factory);
	else if(typeof exports === 'object')
		exports["figtree"] = factory(require("d3"));
	else
		root["figtree"] = factory(root["d3"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_d3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: Tree, Type, ArcLayout, RectangularLayout, TransmissionLayout, FigTree, Bauble, CircleBauble, RectangularBauble, Layout, Graph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/tree.js */ \"./src/tree.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Tree\", function() { return _src_tree_js__WEBPACK_IMPORTED_MODULE_0__[\"Tree\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Type\", function() { return _src_tree_js__WEBPACK_IMPORTED_MODULE_0__[\"Type\"]; });\n\n/* harmony import */ var _src_layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/layout.js */ \"./src/layout.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Layout\", function() { return _src_layout_js__WEBPACK_IMPORTED_MODULE_1__[\"Layout\"]; });\n\n/* harmony import */ var _src_rectangularLayout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/rectangularLayout.js */ \"./src/rectangularLayout.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RectangularLayout\", function() { return _src_rectangularLayout_js__WEBPACK_IMPORTED_MODULE_2__[\"RectangularLayout\"]; });\n\n/* harmony import */ var _src_transmissionLayout_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/transmissionLayout.js */ \"./src/transmissionLayout.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TransmissionLayout\", function() { return _src_transmissionLayout_js__WEBPACK_IMPORTED_MODULE_3__[\"TransmissionLayout\"]; });\n\n/* harmony import */ var _src_arcLayout_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/arcLayout.js */ \"./src/arcLayout.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ArcLayout\", function() { return _src_arcLayout_js__WEBPACK_IMPORTED_MODULE_4__[\"ArcLayout\"]; });\n\n/* harmony import */ var _src_bauble_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/bauble.js */ \"./src/bauble.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Bauble\", function() { return _src_bauble_js__WEBPACK_IMPORTED_MODULE_5__[\"Bauble\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CircleBauble\", function() { return _src_bauble_js__WEBPACK_IMPORTED_MODULE_5__[\"CircleBauble\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RectangularBauble\", function() { return _src_bauble_js__WEBPACK_IMPORTED_MODULE_5__[\"RectangularBauble\"]; });\n\n/* harmony import */ var _src_figtree_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/figtree.js */ \"./src/figtree.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FigTree\", function() { return _src_figtree_js__WEBPACK_IMPORTED_MODULE_6__[\"FigTree\"]; });\n\n/* harmony import */ var _src_Graph_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/Graph.js */ \"./src/Graph.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return _src_Graph_js__WEBPACK_IMPORTED_MODULE_7__[\"Graph\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://figtree/./index.js?");

/***/ }),

/***/ "./src/Graph.js":
/*!**********************!*\
  !*** ./src/Graph.js ***!
  \**********************/
/*! exports provided: Graph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return Graph; });\n\n/** @module Graph */\n\n// import {Type} from 'figtree';\n/**\n * The graph class\n *\n * A class that takes an arrary of nodes and edges and provides a number of methods\n * for manipulating the graph.\n * @param nodes - an array of nodes. Should contain a unique id identifier\n * @param edges - an array of edges linking the nodes {source:node.id,target:node.id}\n */\nclass Graph{\n    constructor(nodes=[],edges=[],settings={acyclicSelector:(e)=>true}) {\n        \n        this.nodeList = [];\n        this.nodeMap = new Map();\n        this.outGoingEdgeMap = new Map();\n        this.incomingEdgeMap= new Map();\n        this.edgeList = [];\n        this.edgeMap = new Map();  \n        this.acyclicSelector=settings.acyclicSelector;\n\n\n        nodes.forEach(node=>this.addNode(node));\n        edges.forEach(edge=>this.drawEdge(edge.source,edge.target));\n        // This is used in identifying terminal tips  \n    };\n    /**\n     * A static function to make a graph out of a tree\n     * @param {*} tree \n     * @returns {Graph}\n     */\n    static fromPhylogeny(tree){\n        const nodes = tree.externalNodes;\n        // links inferred from the transmission layout\n        // will also need a call back somewhere to update the links\n        \n    }\n    /**\n     * @returns {*}\n     */\n    get nodes(){\n        return this.nodeList;\n    }\n    /**\n     * @returns {*}\n     */\n    get externalNodes(){\n        return this.nodeList.filter(d=>this.getOutgoingEdges().length===0);\n    }\n    /**\n     * Adds a node to the graph.\n     * @param {*} node \n     */\n    addNode(node){\n        if(!node.id){\n            throw new Error(`All node's must contain an 'id' key ${node}`)\n        }\n        this.nodeList.push(node);\n        if(this.nodeMap.has(node.id)){\n            throw new Error(`All node's must have unique id values ${node.id} seen twice`)\n        }\n        this.nodeMap.set(node.id,node);\n\n        this.outGoingEdgeMap.set(node,[]);\n        this.incomingEdgeMap.set(node,[]);\n    }\n   \n   /**\n    * return a node given the key\n    * @param {*} id the node id value \n    */\n    getNode(id){\n        return this.nodeMap.get(id);\n    }\n    \n    /**\n     * Get the edges entering a node\n     * @param {*} node \n     * @returns {array} array of edges that end with the node\n     */\n    getIncomingEdges(node){\n        return this.incomingEdgeMap.get(node)\n     }\n     /**\n      * Get the edges leaving a node\n      * @param {*} node \n      * @returns {array} array of edges that begin with the node\n      */\n \n     getOutgoingEdges(node){\n         return this.outGoingEdgeMap.get(node)\n     }\n     /**\n      * Get all the edges leaving and entering a node\n      * @param {*} node\n      * @returns {array} array of edges that touch node\n      */\n     getEdges(node){\n         return (this.getOutgoingEdges(node).concat(this.getIncomingEdges(node)));\n     }\n\n    getNodeInfo(node){\n        // const formatDate=d3.timeFormat(\"%Y-%m-%d\")\n        // let outString = `${node.id} </br>`\n        // // for(const key of Object.keys(node)){\n        // //     if(node[key]){\n        // //         if(key!==\"id\"&& key!==\"metaData\"&&key!==\"key\"){\n        // //             if(key.toLowerCase().indexOf(\"date\")>-1){\n        // //                 outString = `${outString}${key}: ${node[key].toISOString().substring(0, 10)}</br>`;\n        // //                 }else{\n        // //                 outString = `${outString}${key}: ${node[key]}</br>`;\n        // //                 }            \n        // //             }\n        // //     }\n        // // }\n    \n        // for(const key of Object.keys(node.metaData)){\n        //     if(key.toLowerCase().indexOf(\"date\")>-1){\n        //     outString = `${outString}${key}: ${node.metaData[key].toISOString().substring(0, 10)}</br>`;\n        //     }else{\n        //     outString = `${outString}${key}: ${node.metaData[key]}</br>`;\n        //     }\n        // }\n        // return outString;\n    }\n\n    /**\n     * removes the node and incoming/outgoing edges\n     * @param {object} node \n     */\n   \n    removeNode(node){\n        //remove edges\n        const edges = this.getEdges(node);\n        edges.forEach(edge=>this.removeEdge(edge))\n\n        const id=node.id\n        this.nodeList=this.nodeList.filter(node=>node.id!==id);\n        this.nodeMap.delete(id);\n        this.incomingEdgeMap.delete(node);\n        this.outGoingEdgeMap.delete(node);\n    }\n\n    /**\n    * @returns {*} \n    */\n    get edges(){\n    return this.edgeList;\n    }\n    \n    /**\n     * returns the edge\n     * @param {Symbol()} id - symbol key of the edge\n     * @returns {*} edge\n     */\n    getEdge(id){\n        return this.edgeMap.get(id);\n    }\n    getEdgeInfo(edge){\n        // // const formatDate=d3.timeFormat(\"%Y-%m-%d\")\n        // let outString = `Source:${edge.source.id} </br> Target: ${edge.target.id}</br>`;\n        // for(const key of Object.keys(edge.metaData)){\n        //     if(key.toLowerCase().indexOf(\"date\")>-1){\n        //     outString = `${outString}${key}: ${edge.metaData[key].toISOString().substring(0, 10)}</br>`;\n        //     }else{\n        //     outString = `${outString}${key}: ${edge.metaData[key]}</br>`;\n        //     }\n        // }\n        // return outString;\n    }\n     /**\n     * Adds an edge between the provide source and target nodes. It the nodes are not part of the graph they are added.\n     * @param {String} sourceNode Id\n     * @param {String} targetNode Id\n     */\n    drawEdge(sourceNodeId,targetNodeId){\n        if(!this.nodeMap.has(sourceNodeId)){\n            throw new Error(`${sourceNodeId} not found in graph`)\n        }\n        if(!this.nodeMap.has(targetNodeId)){\n            throw new Error(`${targetNodeId} not found in graph`)\n        }\n        const index = this.edgeList.legnth;\n        const edge = {source:this.getNode(sourceNodeId),target:this.getNode(targetNodeId),id:`edge_${index}`};\n        this.addEdge(edge);\n    }\n    /**\n     * Adds an premade edge which between the provide source and target nodes. It the nodes are not part of the graph they are added.\n     * @param {*} {source:node, targe:node} \n     */\n    addEdge(edge){\n        this.edgeList.push(edge);\n        this.edgeMap.set(edge.id,edge);\n        this.outGoingEdgeMap.get(edge.source).push(edge);\n        this.incomingEdgeMap.get(edge.target).push(edge);\n    }\n    \n\n    /**\n     * removes an edge from the graph\n     * @param {*} edge \n     */\n    removeEdge(edge){\n        const id=edge.id\n        this.edgeList=this.edgeList.filter(edge=>edge.id!==id);\n\n        // update edgemaps\n        this.edgeMap.delete(id)\n        // new outgoing\n        const newOutgoing = this.getOutgoingEdges(edge.source).filter(e=>e!==edge);\n        this.outGoingEdgeMap.set(edge.source,newOutgoing);\n        const newIncoming = this.getIncomingEdges(edge.target).filter(e=>e!==edge);\n        this.incomingEdgeMap.set(edge.target,newIncoming);\n\n    }\n\n\n    /**\n     * Inserts a node into an edge. This replaced the edge with two new edges which pass through the node.\n     * @param {*} node \n     * @param {*} edge \n     */\n    insertNode(node,edge){\n        if(!this.nodeMap.has(node.id)){\n            this.addNode(node)\n        }\n        this.drawEdge(edge.source.id,node.id);\n        this.drawEdge(node.id,edge.target.id);\n        this.removeEdge(edge)\n    }\n\n    /**\n     * A function to return a sub graph given an arrary of nodes.\n     * @param {array} nodes - An array of nodes\n     * @param {*} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {*} A graph object including the provided nodes and edges linking the node. If there is no path between all nodes the \n     * object will be empty \n     */\n    getSubGraph(nodes,options={filterEdges:(e)=>true}){\n        // check there is a path between all nodes\n        // const preorder= [...this.preorder(nodes[0])];\n        // if(nodes.some(n=>preorder.indexOf(n)===-1)){ \n        //     // If there is at least 1 node not hit in the traversal\n        //     return new Graph();\n        // }\n        // const edges = nodes.map(n=>[...this.getOutgoingEdges(n).filter(e=>options.filterEdges(e)).filter(e=>nodes.indexOf(e.target)>-1),\n        //                             ...this.getIncomingEdges(n).filter(e=>options.filterEdges(e)).filter(e=>nodes.indexOf(e.source)>-1)]);\n        // const uniqueEdges = [...new Set(edges)];\n        // const subGraph = new Graph();\n        \n        \n        // return new Graph();\n\n        // nodes,uniqueEdges)\n       \n    }\n\n        /**\n     * A function returning \n     * @param {*} nodes - An array of nodes\n     * @param {*} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {*} \n     * Not yet implimented. Should each path be a sub-graph?\n     */\n    getPaths(node1,node2,options={filterEdges:(e)=>true}){\n        // check there is a path between all nodes\n        throw new Error(\"Not yet implimented\");\n\n       \n    }\n\n// -----------  Methods rejigged from figtree.js tree object -----------------------------\n    /**\n     * Reverses the order of the children of the given node. If 'recursive=true' then it will\n     * descend down the subtree reversing all the sub nodes.\n     *\n     * @param node\n     * @param recursive\n     */\n    // add options with edgeFilter callback\n    rotate(node, options={recursive:false}) {\n        const nodesToVisit = [...this.preorder(node)];\n        const outGoingEdges=this.getOutgoingEdges(node);\n\n            if (options.recursive) {\n                for (const n of nodesToVisit) {\n                    //Needs to avoid circulare loops \n                    const nOutGoingEdges=this.getOutgoingEdges(n);\n                    nOutGoingEdges.reverse();\n                }\n            }else{\n                outGoingEdges.reverse();\n\n            }\n        };\n\n    /**\n     * Sorts the child branches of each node in order of increasing or decreasing number\n     * of tips. This operates recursively from the node given.\n     *\n     * @param node - the node to start sorting from\n     * @param {boolean} increasing - sorting in increasing node order or decreasing?\n     * @returns {number} - the number of tips below this node\n     */\n    order(node, increasing) {\n        // // orderNodes.call(this, node, increasing, this.treeUpdateCallback);\n        // orderNodes.call(this, node,increasing);\n        // // this.treeUpdateCallback();\n    }\n\n\n    /**\n     * A generator function that returns the nodes in a pre-order traversal. Starting at \n     * node. An optional options objects can be used to select which edges are used in the traversal\n     * @param {*} node \n     * @param {object} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *preorder(node) {\n        // We have to mark nodes as visited since it is possible to cycle back\n        this.edgeList.forEach(e=>e.visited=false);\n        this.nodeList.forEach(n => n.visited=false);\n        const self = this;\n        const traverse = function *(node){\n            yield node;\n            const edges = self.getEdges(node).filter(e=>self.acyclicSelector(e));\n            // don't need all this if using acyclic edges\n            if(edges.length>0){\n                for(const edge of edges){\n                    if(!edge.visited){\n                        let nextNode;\n                        if(node===edge.source){\n                            nextNode = edge.target;\n                        }else{\n                            nextNode=edge.source;\n                        }\n                        if(!nextNode.visited){\n                            edge.visited=true;\n                            yield* traverse(nextNode);\n                        }else{\n                            edge.visited=true; // technically a back edge\n                        }\n                    }\n                }\n            }\n        };\n        yield* traverse(node);\n        this.edgeList.forEach(e=> delete e[\"visited\"]);\n        this.nodeList.forEach(n => delete n[\"visited\"]);\n    }\n\n    /**\n     * A generator function that returns the nodes in a post-order traversal. Starting at \n     * node. An optional options objects can be used to select which edges are used in the traversal\n     * @param {*} node \n     * @param {object} options - an optional object with filterEdges:function() that filters the edges used in the traversal\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *postorder(node) {\n        // We have to mark nodes as visited since it is possible to cycle back\n        this.edgeList.forEach(e=>e.visited=false);\n        this.nodeList.forEach(n => n.visited=false);\n        const self=this;\n        const traverse = function *(node){\n            const edges = self.getEdges(node).filter(e=>self.acyclicSelector(e));\n            // don't need all this if using acyclic edges\n            if(edges.length>0){\n                for(const edge of edges){\n                    if(!edge.visited){\n                        let nextNode;\n                        if(node===edge.source){\n                            nextNode = edge.target;\n                        }else{\n                            nextNode=edge.source;\n                        }\n                        if(!nextNode.visited){\n                            edge.visited=true;\n                            yield* traverse(nextNode);\n                        }else{\n                            edge.visited=true; // technically a back edge\n                        }\n                    }\n                }  \n            }\n            yield node;\n\n        };\n        yield* traverse(node);\n        this.edgeList.forEach(e=> delete e[\"visited\"]);\n        this.nodeList.forEach(n => delete n[\"visited\"]);\n    }\n\n}\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n/**\n * A private recursive function that rotates nodes to give an ordering.\n * @param node\n * @param increasing\n * @param callback an optional callback that is called each rotate\n * @returns {number}\n */\nfunction orderNodes(node, increasing, callback = null) {\n    // const factor = increasing ? 1 : -1;\n    // let count = 1;\n    // const pathsOut=this.getOutgoingEdges(node);\n    // if (pathsOut.length>0) {\n    //     const counts = new Map();\n    //     for (const child of pathsOut.map(e=>e.target) ) {\n    //         const value = orderNodes.call(this,child, increasing, callback);\n    //         counts.set(child, value);\n    //         count += value;\n    //     }\n    //     console.log(counts)\n    //     pathsOut.sort((a, b) => {\n    //         return (counts.get(a.target) - counts.get(b.target)) * factor\n    //     });\n\n    //     if (callback) callback();\n    // } else {\n    //     count = 1\n    // }\n    // return count;\n}\n\n\n\n//# sourceURL=webpack://figtree/./src/Graph.js?");

/***/ }),

/***/ "./src/arcLayout.js":
/*!**************************!*\
  !*** ./src/arcLayout.js ***!
  \**************************/
/*! exports provided: ArcLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArcLayout\", function() { return ArcLayout; });\n/* harmony import */ var _layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout.js */ \"./src/layout.js\");\n/* harmony import */ var _tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tree.js */ \"./src/tree.js\");\n\n\n/** @module layout */\n\n\n\nconst d3 = __webpack_require__(/*! d3 */ \"d3\");\n\n/**\n * The Layout class\n *\n */\nclass ArcLayout extends _layout_js__WEBPACK_IMPORTED_MODULE_0__[\"Layout\"] {\n\n    static DEFAULT_SETTINGS() {\n        return {\n            lengthFormat: d3.format(\".2f\"),\n            edgeWidth:2,\n            xFunction:(n,i)=>i,\n            branchCurve:d3.curveLinear\n        };\n    }\n\n    /**\n     * The constructor.\n     * @param tree\n     * @param settings\n     */\n    constructor(graph, settings = { }) {\n        super();\n\n        this.graph = graph;\n\n        // merge the default settings with the supplied settings\n        this.settings = {...ArcLayout.DEFAULT_SETTINGS(), ...settings};\n\n        this.branchLabelAnnotationName = null;\n        this.internalNodeLabelAnnotationName = null;\n        this.externalNodeLabelAnnotationName = null;\n\n        // called whenever the tree changes...\n        // this.tree.treeUpdateCallback = () => {\n        //     this.update();\n        // };\n    }\n\n    /**\n     * Lays out the tree in a standard rectangular format.\n     *\n     * This function is called by the FigTree class and is used to layout the nodes of the tree. It\n     * populates the vertices array with vertex objects that wrap the nodes and have coordinates and\n     * populates the edges array with edge objects that have two vertices.\n     *\n     * It encapsulates the tree object to keep it abstract\n     *\n     * @param vertices - objects with an x, y coordinates and a reference to the original node\n     * @param edges - objects with v1 (a vertex) and v0 (the parent vertex).\n     */\n    layout(vertices, edges) {\n\n        this._horizontalRange = [0.0, d3.max(this.graph.nodes,(n,i)=>this.settings.xFunction(n,i))];\n        this._verticalRange = [-this.graph.nodes.length,this.graph.nodes.length];\n\n        // get the nodes in pre-order (starting at first node)\n        const nodes = [...this.graph.preorder(this.graph.nodes[0])];\n\n\n        if (vertices.length === 0) {\n            this.nodeMap = new Map();\n\n            // create the vertices (only done if the array is empty)\n            nodes.forEach((n, i) => {\n                const vertex = {\n                    node: n,\n                    key: n.id\n                    // key: Symbol(n.id).toString()\n                };\n                vertices.push(vertex);\n                this.nodeMap.set(n, vertex);\n            });\n        }\n\n        // update the node locations (vertices)\n        //\n        nodes\n            .forEach((n,i) => {\n                const v = this.nodeMap.get(n);\n\n                v.x = this.settings.xFunction(n,i);\n                v.y=0;\n\n                v.degree = this.graph.getEdges(v.node).length ; // the number of edges \n\n                v.classes = [\n                    (!this.graph.getOutgoingEdges(v.node).length>0? \"external-node\" : \"internal-node\"),\n                    (v.node.isSelected ? \"selected\" : \"unselected\")];\n\n                if (v.node.annotations) {\n                    v.classes = [\n                        ...v.classes,\n                        ...Object.entries(v.node.annotations)\n                            .filter(([key]) => {\n                                return this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].DISCRETE ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].BOOLEAN ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].INTEGER;\n                            })\n                            .map(([key, value]) => `${key}-${value}`)];\n                }\n\n                // either the tip name or the internal node label\n                if (v.node.children) {\n                    v.leftLabel = (this.internalNodeLabelAnnotationName?\n                        v.node.annotations[this.internalNodeLabelAnnotationName]:\n                        \"\");\n                    v.rightLabel = \"\";\n\n                    // should the left node label be above or below the node?\n                    v.labelBelow = (!v.node.parent || v.node.parent.children[0] !== v.node);\n                } else {\n                    v.leftLabel = \"\";\n                    v.rightLabel = (this.externalNodeLabelAnnotationName?\n                        v.node.annotations[this.externalNodeLabelAnnotationName]:\n                        v.node.name);\n                }\n\n                this.nodeMap.set(v.node, v);\n            });\n\n        if (edges.length === 0) {\n            this.edgeMap = new Map();\n\n            // create the edges (only done if the array is empty)\n            const dataEdges = this.graph.edges;\n            dataEdges\n                .forEach((e, i) => {\n                    const edge = {\n                        v0: this.nodeMap.get(e.source),\n                        v1: this.nodeMap.get(e.target),\n                        key: e.id\n                        // key: Symbol(n.id).toString()\n                    };\n                    edges.push(edge);\n                    this.edgeMap.set(edge, edge.v1);\n                });\n        }\n\n        // update the edges\n\n\n        edges\n            .forEach((e) => {\n                e.v1 = this.edgeMap.get(e);\n                e.v0 = this.nodeMap.get(e.v0.node),\n                    e.classes = [];\n\n\n                if (e.v1.node.annotations) {\n                    e.classes = [\n                        ...e.classes,\n                        ...Object.entries(e.v1.node.annotations)\n                            .filter(([key]) => {\n                                return this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].DISCRETE ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].BOOLEAN ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].INTEGER;\n                            })\n                            .map(([key, value]) => `${key}-${value}`)];\n                }\n                const length = e.v1.x - e.v0.x;\n                e.length = length;\n                e.label = (this.branchLabelAnnotationName ?\n                    (this.branchLabelAnnotationName === 'length' ?\n                        this.settings.lengthFormat(length) :\n                        e.v1.node.annotations[this.branchLabelAnnotationName]) :\n                    null );\n                // e.labelBelow = e.v1.node.parent.children[0] !== e.v1.node;\n            });\n    }\n\n    set branchCurve(curve) {\n        this.settings.branchCurve = curve;\n        this.update();\n    }\n\n\n    get branchCurve() {\n        return this.settings.branchCurve;\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setInternalNodeLabels(annotationName) {\n        this.internalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setExternalNodeLabels(annotationName) {\n        this.externalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setBranchLabels(annotationName) {\n        this.branchLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n        this.updateCallback();\n    }\n// do it with interpelations\n    branchPathGenerator(scales){\n            const branchPath =(e,i)=>{\n                const branchLine = d3.line()\n                     .x((v) => v.x)\n                    .y((v) => v.y)\n                    .curve(this.branchCurve);\n            const r = (scales.x(e.v1.x) - scales.x(e.v0.x))/2\n            const a = r; // center x position\n            const sign = i%2===0?1:-1;\n            const x = d3.range(0,scales.x(e.v1.x) - scales.x(e.v0.x),1)//step every pixel\n            const y = x.map(x=>circleY.call(this,x,r,a,sign));\n            const points = x.map((x,i)=>{\n                return{x:x,y:y[i]}\n            })        \n            return(\n                branchLine(\n                    points\n                )\n            )\n            \n        }\n        return branchPath;\n    }\n\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\nfunction circleY(x,r,a,sign){\n        return  sign*(Math.sqrt(Math.pow(r,2)-Math.pow((x-a),2)))\n}\n\n\n\n//# sourceURL=webpack://figtree/./src/arcLayout.js?");

/***/ }),

/***/ "./src/bauble.js":
/*!***********************!*\
  !*** ./src/bauble.js ***!
  \***********************/
/*! exports provided: Bauble, CircleBauble, RectangularBauble */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bauble\", function() { return Bauble; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CircleBauble\", function() { return CircleBauble; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectangularBauble\", function() { return RectangularBauble; });\n\n\n/** @module bauble */\n\n\n/**\n * The Bauble class\n *\n * This is a shape or decoration at the node of a tree or graph\n */\nclass Bauble {\n    static DEFAULT_SETTINGS() {\n        return {\n            vertexFilter: () => true\n        };\n    }\n\n    /**\n     * The constructor.\n     */\n    constructor(settings = {}) {\n        this.settings = {...Bauble.DEFAULT_SETTINGS(), ...settings};\n    }\n\n    get vertexFilter() {\n        return this.settings.vertexFilter;\n    }\n\n    createShapes(selection) {\n        throw new Error(\"don't call the base class methods\")\n    }\n\n    updateShapes(selection, border = 0) {\n        throw new Error(\"don't call the base class methods\")\n    }\n\n}\n\nclass CircleBauble extends Bauble {\n    static DEFAULT_SETTINGS() {\n        return {\n            radius: 6,\n        };\n    }\n\n    /**\n     * The constructor.\n     */\n    constructor(settings = {}) {\n        super({...CircleBauble.DEFAULT_SETTINGS(), ...settings});\n    }\n\n    createShapes(selection) {\n        return selection\n            .append(\"circle\");\n    };\n\n    updateShapes(selection, border = 0) {\n        return selection\n            .attr(\"cx\", 0)\n            .attr(\"cy\", 0)\n            .attr(\"r\", this.settings.radius + border);\n    };\n}\n\nclass RectangularBauble extends Bauble {\n    static DEFAULT_SETTINGS() {\n        return {\n            height: 16,\n            width: 6,\n            radius: 2,\n        };\n    }\n\n    /**\n     * The constructor.\n     */\n    constructor(settings = {}) {\n        super({...RectangularBauble.DEFAULT_SETTINGS(), ...settings});\n    }\n\n    createShapes(selection) {\n        return selection\n            .append(\"rect\");\n    };\n\n    updateShapes(selection, border = 0) {\n        const w = this.settings.width + border;\n        const h = this.settings.height + border;\n        return selection\n            .attr(\"x\", - w / 2)\n                .attr(\"width\", w)\n                .attr(\"y\", - h / 2)\n                .attr(\"height\", h)\n                .attr(\"rx\", this.settings.radius)\n                .attr(\"ry\", this.settings.radius);\n    };\n}\n\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n\n\n//# sourceURL=webpack://figtree/./src/bauble.js?");

/***/ }),

/***/ "./src/figtree.js":
/*!************************!*\
  !*** ./src/figtree.js ***!
  \************************/
/*! exports provided: FigTree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FigTree\", function() { return FigTree; });\n\n\n/** @module figtree */\nconst d3 = __webpack_require__(/*! d3 */ \"d3\");\n\n/**\n * The FigTree class\n *\n * A class that takes a tree and draws it into the the given SVG root element. Has a range of methods\n * for adding interactivity to the tree (e.g., mouse-over labels, rotating nodes and rerooting on branches).\n * The tree is updated with animated transitions.\n */\nclass FigTree {\n\n    static DEFAULT_SETTINGS() {\n        return {\n            xAxisTickArguments: [5, \"f\"],\n            xAxisTitle: \"Divergence\",\n            // nodeRadius: 6,\n            hoverBorder: 2,\n            backgroundBorder: 0,\n            baubles: []\n        };\n    }\n\n    /**\n     * The constructor.\n     * @param svg\n     * @param layout - an instance of class Layout\n     * @param margins\n     * @param settings\n     */\n    constructor(svg, layout, margins, settings = {}) {\n        this.layout = layout;\n        this.margins = margins;\n\n        // merge the default settings with the supplied settings\n        this.settings = {...FigTree.DEFAULT_SETTINGS(), ...settings};\n\n        // get the size of the svg we are drawing on\n        const width = svg.getBoundingClientRect().width;\n        const height = svg.getBoundingClientRect().height;\n\n        //remove the tree if it is there already\n        d3.select(svg).select(\"g\").remove();\n\n        // add a group which will contain the new tree\n        d3.select(svg).append(\"g\")\n            .attr(\"transform\",`translate(${margins.left},${margins.top})`);\n\n        //to selecting every time\n        this.svgSelection = d3.select(svg).select(\"g\");\n\n        this.svgSelection.append(\"g\").attr(\"class\", \"axes-layer\");\n        this.svgSelection.append(\"g\").attr(\"class\", \"branches-layer\");\n        if (this.settings.backgroundBorder > 0) {\n            this.svgSelection.append(\"g\").attr(\"class\", \"nodes-background-layer\");\n        }\n        this.svgSelection.append(\"g\").attr(\"class\", \"nodes-layer\");\n\n        // create the scales\n        const xScale = d3.scaleLinear()\n            .domain(this.layout.horizontalRange)\n            .range([margins.left, width - margins.right]);\n\n        const yScale = d3.scaleLinear()\n            .domain(this.layout.verticalRange)\n            .range([margins.top + 20, height - margins.bottom - 20]);\n\n        this.scales = {x:xScale, y:yScale, width, height};\n\n        addAxis.call(this, margins);\n\n        this.vertices = [];\n        this.edges = [];\n\n        // Called whenever the layout changes...\n        this.layout.updateCallback = () => {\n            this.update();\n        }\n\n        this.update();\n    }\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n\n        // get new positions\n        this.layout.layout(this.vertices, this.edges);\n\n        // update the scales' domains\n        this.scales.x.domain(this.layout.horizontalRange);\n        this.scales.y.domain(this.layout.verticalRange);\n\n        const xAxis = d3.axisBottom(this.scales.x)\n            .tickArguments(this.settings.xAxisTickArguments);\n\n        this.svgSelection.select(\"#x-axis\")\n            .transition()\n            .duration(500)\n            .call(xAxis);\n\n\n        // call the private methods to create the components of the diagram\n        updateBranches.call(this);\n\n        if (this.settings.backgroundBorder > 0) {\n            updateNodeBackgrounds.call(this);\n        }\n\n        updateNodes.call(this);\n\n    }\n\n    /**\n     * set mouseover highlighting of branches\n     */\n    hilightBranches() {\n        // need to use 'function' here so that 'this' refers to the SVG\n        // element being hovered over.\n        const selected = this.svgSelection.selectAll(\".branch\").select(\".branch-path\");\n        selected.on(\"mouseover\", function (d, i) {\n            d3.select(this).classed(\"hovered\", true);\n        });\n        selected.on(\"mouseout\", function (d, i) {\n            d3.select(this).classed(\"hovered\", false);\n        });\n    }\n\n    /**\n     * Set mouseover highlighting of internal nodes\n     */\n    hilightInternalNodes() {\n        this.hilightNodes(\".internal-node\");\n    }\n\n    /**\n     * Set mouseover highlighting of internal nodes\n     */\n    hilightExternalNodes() {\n        this.hilightNodes(\".external-node\");\n    }\n\n    /**\n     * Set mouseover highlighting of nodes\n     */\n    hilightNodes(selection) {\n        // need to use 'function' here so that 'this' refers to the SVG\n        // element being hovered over.\n        const self = this;\n        const selected = this.svgSelection.selectAll(selection).select(\".node-shape\");\n        selected.on(\"mouseover\", function (d, i) {\n            const node = d3.select(this);\n\n            self.settings.baubles.forEach((bauble) => {\n                if (bauble.vertexFilter(node)) {\n                    bauble.updateShapes(node, self.settings.hoverBorder);\n                }\n            });\n\n            node.classed(\"hovered\", true);\n        });\n        selected.on(\"mouseout\", function (d, i) {\n            const node = d3.select(this);\n\n            self.settings.baubles.forEach((bauble) => {\n                if (bauble.vertexFilter(node)) {\n                    bauble.updateShapes(node, 0);\n                }\n            });\n\n            node.classed(\"hovered\", false);\n        });\n    }\n\n    /**\n     * Registers action function to be called when an edge is clicked on. The function is passed\n     * edge object that was clicked on and the position of the click as a proportion of the edge length.\n     *\n     * Optionally a selection string can be provided - i.e., to select a particular branch by its id.\n     *\n     * @param action\n     * @param selection\n     */\n    onClickBranch(action, selection = null) {\n        // We need to use the \"function\" keyword here (rather than an arrow) so that \"this\"\n        // points to the actual SVG element (so we can use d3.mouse(this)). We therefore need\n        // to store a reference to the object in \"self\".\n        const self = this;\n        const selected = this.svgSelection.selectAll(`${selection ? selection : \".branch\"}`);\n        selected.on(\"click\", function (edge) {\n            const x1 = self.scales.x(edge.v1.x);\n            const x2 = self.scales.x(edge.v0.x);\n            const mx = d3.mouse(this)[0];\n            const proportion = Math.max(0.0, Math.min(1.0, (mx - x2) / (x1 - x2)));\n            action(edge, proportion);\n        })\n    }\n\n    /**\n     * Registers action function to be called when an internal node is clicked on. The function should\n     * take the tree and the node that was clicked on.\n     *\n     * A static method - Tree.rotate() is available for rotating the node order at the clicked node.\n     *\n     * @param action\n     */\n    onClickInternalNode(action) {\n        this.onClickNode(action, \".internal-node\");\n    }\n\n    /**\n     * Registers action function to be called when an external node is clicked on. The function should\n     * take the tree and the node that was clicked on.\n     *\n     * @param action\n     */\n    onClickExternalNode(action) {\n        this.onClickNode(action, \".external-node\");\n    }\n\n    /**\n     * Registers action function to be called when a vertex is clicked on. The function is passed\n     * the vertex object.\n     *\n     * Optionally a selection string can be provided - i.e., to select a particular node by its id.\n     *\n     * @param action\n     * @param selection\n     */\n    onClickNode(action, selection = null) {\n        const selected = this.svgSelection.selectAll(`${selection ? selection : \".node\"}`).select(\".node-shape\");\n        selected.on(\"click\", (vertex) => {\n            action(vertex);\n        })\n    }\n\n    /**\n     * Registers some text to appear in a popup box when the mouse hovers over the selection.\n     *\n     * @param selection\n     * @param text\n     */\n    addToolTip(selection, text) {\n        this.svgSelection.selectAll(selection).on(\"mouseover\",\n            function (selected) {\n                let tooltip = document.getElementById(\"tooltip\");\n                if (typeof text === typeof \"\") {\n                    tooltip.innerHTML = text;\n                } else {\n                    tooltip.innerHTML = text(selected.node);\n                }\n                tooltip.style.display = \"block\";\n                tooltip.style.left = d3.event.pageX + 10 + \"px\";\n                tooltip.style.top = d3.event.pageY + 10 + \"px\";\n            }\n        );\n        this.svgSelection.selectAll(selection).on(\"mouseout\", function () {\n            let tooltip = document.getElementById(\"tooltip\");\n            tooltip.style.display = \"none\";\n        });\n    }\n\n    set treeLayout(layout) {\n        this.layout = layout;\n        this.update();\n    }\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n/**\n * Adds or updates nodes\n */\nfunction updateNodes() {\n\n    const nodesLayer = this.svgSelection.select(\".nodes-layer\");\n\n    // DATA JOIN\n    // Join new data with old elements, if any.\n    const nodes = nodesLayer.selectAll(\".node\")\n        .data(this.vertices, (v) => `n_${v.key}`);\n\n    // ENTER\n    // Create new elements as needed.\n    const newNodes = nodes.enter().append(\"g\")\n        .attr(\"id\", (v) => v.id)\n        .attr(\"class\", (v) => [\"node\", ...v.classes].join(\" \"))\n        .attr(\"transform\", (v) => {\n            return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n        });\n\n    // add the specific node shapes or 'baubles'\n    this.settings.baubles.forEach((bauble) => {\n        const d = bauble\n            .createShapes(newNodes.filter(bauble.vertexFilter))\n            .attr(\"class\", \"node-shape\");\n        bauble.updateShapes(d);\n    });\n\n    newNodes.append(\"text\")\n        .attr(\"class\", \"node-label name\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"alignment-baseline\", \"middle\")\n        .attr(\"dx\", \"12\")\n        .attr(\"dy\", \"0\")\n        .text((d) => d.rightLabel);\n\n    newNodes.append(\"text\")\n        .attr(\"class\", \"node-label support\")\n        .attr(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-6\")\n        .attr(\"dy\", d => (d.labelBelow ? -8 : +8))\n        .attr(\"alignment-baseline\", d => (d.labelBelow ? \"bottom\": \"hanging\" ))\n        .text((d) => d.leftLabel);\n\n    // update the existing elements\n    nodes\n        .transition()\n        .duration(500)\n        .attr(\"class\", (v) => [\"node\", ...v.classes].join(\" \"))\n        .attr(\"transform\", (v) => {\n            return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n        });\n\n    // update all the baubles\n    this.settings.baubles.forEach((bauble) => {\n        const d = nodes.select(\".node-shape\")\n            .filter(bauble.vertexFilter)\n            .transition()\n            .duration(500);\n        bauble.updateShapes(d)\n    });\n\n    nodes.select(\"text .node-label .name\")\n        .transition()\n        .duration(500)\n        .attr(\"class\", \"node-label name\")\n        .attr(\"text-anchor\", \"start\")\n        .attr(\"alignment-baseline\", \"middle\")\n        .attr(\"dx\", \"12\")\n        .attr(\"dy\", \"0\")\n        .text((d) => d.rightLabel);\n\n    nodes.select(\"text .node-label .support\")\n        .transition()\n        .duration(500)\n        .attr(\"alignment-baseline\", d => (d.labelBelow ? \"bottom\": \"hanging\" ))\n        .attr(\"class\", \"node-label support\")\n        .attr(\"text-anchor\", \"end\")\n        .attr(\"dx\", \"-6\")\n        .attr(\"dy\", d => (d.labelBelow ? -8 : +8))\n        .text((d) => d.leftLabel);\n\n    // EXIT\n    // Remove old elements as needed.\n    nodes.exit().remove();\n\n}\n\nfunction updateNodeBackgrounds() {\n\n    const nodesBackgroundLayer = this.svgSelection.select(\".nodes-background-layer\");\n\n    // DATA JOIN\n    // Join new data with old elements, if any.\n    const nodes = nodesBackgroundLayer.selectAll(\".node-background\")\n        .data(this.vertices, (v) => `nb_${v.key}`);\n\n    // ENTER\n    // Create new elements as needed.\n    const newNodes = nodes.enter();\n\n    // add the specific node shapes or 'baubles'\n    this.settings.baubles.forEach((bauble) => {\n        const d = bauble\n            .createShapes(newNodes.filter(bauble.vertexFilter))\n            .attr(\"class\", \"node-background\")\n            .attr(\"transform\", (v) => {\n                return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n            });\n\n        bauble.updateShapes(d, this.settings.backgroundBorder);\n    });\n\n    // update all the existing elements\n    this.settings.baubles.forEach((bauble) => {\n        const d = nodes\n            .filter(bauble.vertexFilter)\n            .transition()\n            .duration(500)\n            .attr(\"transform\", (v) => {\n                return `translate(${this.scales.x(v.x)}, ${this.scales.y(v.y)})`;\n            });\n        bauble.updateShapes(d, this.settings.backgroundBorder)\n    });\n\n    // EXIT\n    // Remove old elements as needed.\n    nodes.exit().remove();\n\n}\n\n\n/**\n * Adds or updates branch lines\n */\nfunction updateBranches() {\n\n    const branchesLayer = this.svgSelection.select(\".branches-layer\");\n\n    // a function to create a line path\n    // const branchPath = d3.line()\n    //     .x((v) => v.x)\n    //     .y((v) => v.y)\n    //     .curve(this.layout.branchCurve);\n    const branchPath = this.layout.branchPathGenerator(this.scales)\n\n    // DATA JOIN\n    // Join new data with old elements, if any.\n    const branches = branchesLayer.selectAll(\"g .branch\")\n        .data(this.edges, (e) => `b_${e.key}`);\n\n    // ENTER\n    // Create new elements as needed.\n    const newBranches = branches.enter().append(\"g\")\n        .attr(\"id\", (e) => e.id)\n        .attr(\"class\", (e) => [\"branch\", ...e.classes].join(\" \"))\n        .attr(\"transform\", (e) => {\n            return `translate(${this.scales.x(e.v0.x)}, ${this.scales.y(e.v1.y)})`;\n        });\n\n    newBranches.append(\"path\")\n        .attr(\"class\", \"branch-path\")\n        .attr(\"d\", (e,i) => branchPath(e,i));\n\n    newBranches.append(\"text\")\n        .attr(\"class\", \"branch-label length\")\n        .attr(\"dx\", (e) => ((this.scales.x(e.v1.x) - this.scales.x(e.v0.x)) / 2))\n        .attr(\"dy\", (e) => (e.labelBelow ? +6 : -6))\n        .attr(\"alignment-baseline\", (e) => (e.labelBelow ? \"hanging\" : \"bottom\"))\n        .attr(\"text-anchor\", \"middle\")\n        .text((e) => e.label);\n\n    // update the existing elements\n    branches\n        .transition()\n        .duration(500)\n        .attr(\"class\", (e) => [\"branch\", ...e.classes].join(\" \"))\n        .attr(\"transform\", (e) => {\n            return `translate(${this.scales.x(e.v0.x)}, ${this.scales.y(e.v1.y)})`;\n        })\n\n        .select(\"path\")\n        .attr(\"d\", (e,i) => branchPath(e,i))\n\n        .select(\"text .branch-label .length\")\n        .attr(\"class\", \"branch-label length\")\n        .attr(\"dx\", (e) => ((this.scales.x(e.v1.x) - this.scales.x(e.v0.x)) / 2))\n        .attr(\"dy\", (e) => (e.labelBelow ? +6 : -6))\n        .attr(\"alignment-baseline\", (e) => (e.labelBelow ? \"hanging\" : \"bottom\"))\n        .attr(\"text-anchor\", \"middle\")\n        .text((e) => e.label);\n\n    // EXIT\n    // Remove old elements as needed.\n    branches\n        .exit().remove();\n}\n\n/**\n * Add axis\n */\nfunction addAxis() {\n    const xAxis = d3.axisBottom(this.scales.x)\n        .tickArguments(this.settings.xAxisTickArguments);\n\n    const xAxisWidth = this.scales.width - this.margins.left - this.margins.right;\n\n    const axesLayer = this.svgSelection.select(\".axes-layer\");\n\n    axesLayer\n        .append(\"g\")\n        .attr(\"id\", \"x-axis\")\n        .attr(\"class\", \"axis\")\n        .attr(\"transform\", `translate(0, ${this.scales.height - this.margins.bottom + 5})`)\n        .call(xAxis);\n\n    axesLayer\n        .append(\"g\")\n        .attr(\"id\", \"x-axis-label\")\n        .attr(\"class\", \"axis-label\")\n        .attr(\"transform\", `translate(${this.margins.left}, ${this.scales.height - this.margins.bottom})`)\n        .append(\"text\")\n        .attr(\"transform\", `translate(${xAxisWidth / 2}, 35)`)\n        .attr(\"alignment-baseline\", \"hanging\")\n        .style(\"text-anchor\", \"middle\")\n        .text(this.settings.xAxisTitle);\n}\n\n\n//# sourceURL=webpack://figtree/./src/figtree.js?");

/***/ }),

/***/ "./src/layout.js":
/*!***********************!*\
  !*** ./src/layout.js ***!
  \***********************/
/*! exports provided: Layout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layout\", function() { return Layout; });\n\n\n/** @module layout */\n\n\n/**\n * The Layout class\n *\n */\nclass Layout {\n\n    /**\n     * The constructor.\n     */\n    constructor( ) {\n\n        // default ranges - these should be set in layout()\n        this._horizontalRange = [0.0, 1.0];\n        this._verticalRange = [0, 1.0];\n\n        // create an empty callback function\n        this.updateCallback = () => { };\n    }\n\n    /**\n     * An abstract base class for a layout class. The aim is to describe the API of the class.\n     *\n     * @param vertices - objects with an x, y coordinates and a reference to the original node\n     * @param edges - objects with v1 (a vertex) and v0 (the parent vertex).\n     */\n    layout(vertices, edges) { }\n\n    get horizontalRange() {\n        return this._horizontalRange;\n    }\n\n    get verticalRange() {\n        return this._verticalRange;\n    }\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n        this.updateCallback();\n    }\n\n    /**\n     * A utility function for rotating a node\n     * @returns {rotate}\n     */\n    rotate() {\n        return (vertex) => {\n            this.tree.rotate(vertex.node);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function for ordering a subtree with increasing tip density\n     * @returns {orderIncreasing}\n     */\n    orderIncreasing() {\n        return (vertex) => {\n            this.tree.rotate(vertex.node);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function for ordering a subtree with decreasing tip density\n     * @returns {orderIncreasing}\n     */\n    orderDecreasing() {\n        return (vertex) => {\n            this.tree.rotate(vertex.node);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function for rerooting the tree\n     * @returns {reroot}\n     */\n    reroot() {\n        return (edge, position) => {\n            this.tree.reroot(edge.v1.node, position);\n            this.update();\n        };\n    }\n\n    /**\n     * A utility function that will return a HTML string about the node and its\n     * annotations. Can be used with the addLabels() method.\n     *\n     * @param node\n     * @returns {string}\n     */\n    static nodeInfo(node) {\n        let text = `${node.name ? node.name : node.id }`;\n        Object.entries(node.annotations).forEach(([key, value]) => {\n            text += `<p>${key}: ${value}</p>`;\n        });\n        return text;\n    }\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n\n\n//# sourceURL=webpack://figtree/./src/layout.js?");

/***/ }),

/***/ "./src/rectangularLayout.js":
/*!**********************************!*\
  !*** ./src/rectangularLayout.js ***!
  \**********************************/
/*! exports provided: RectangularLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectangularLayout\", function() { return RectangularLayout; });\n/* harmony import */ var _layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout.js */ \"./src/layout.js\");\n/* harmony import */ var _tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tree.js */ \"./src/tree.js\");\n\n\n/** @module layout */\n\n\n\nconst d3 = __webpack_require__(/*! d3 */ \"d3\");\n/**\n * The Layout class\n *\n */\nclass RectangularLayout extends _layout_js__WEBPACK_IMPORTED_MODULE_0__[\"Layout\"] {\n\n    static DEFAULT_SETTINGS() {\n        return {\n            lengthFormat: d3.format(\".2f\"),\n            branchCurve: d3.curveStepBefore\n        };\n    }\n\n    /**\n     * The constructor.\n     * @param tree\n     * @param settings\n     */\n    constructor(tree, settings = { }) {\n        super();\n\n        this.tree = tree;\n\n        // merge the default settings with the supplied settings\n        this.settings = {...RectangularLayout.DEFAULT_SETTINGS(), ...settings};\n\n        this.branchLabelAnnotationName = null;\n        this.internalNodeLabelAnnotationName = null;\n        this.externalNodeLabelAnnotationName = null;\n\n        // called whenever the tree changes...\n        this.tree.treeUpdateCallback = () => {\n            this.update();\n        };\n    }\n\n    /**\n     * Lays out the tree in a standard rectangular format.\n     *\n     * This function is called by the FigTree class and is used to layout the nodes of the tree. It\n     * populates the vertices array with vertex objects that wrap the nodes and have coordinates and\n     * populates the edges array with edge objects that have two vertices.\n     *\n     * It encapsulates the tree object to keep it abstract\n     *\n     * @param vertices - objects with an x, y coordinates and a reference to the original node\n     * @param edges - objects with v1 (a vertex) and v0 (the parent vertex).\n     */\n    layout(vertices, edges) {\n\n        this._horizontalRange = [0.0, d3.max([...this.tree.rootToTipLengths()])];\n        this._verticalRange = [0, this.tree.externalNodes.length - 1];\n\n        // get the nodes in post-order\n        const nodes = [...this.tree.postorder()];\n\n        let currentY = -1;\n\n        if (vertices.length === 0) {\n            this.nodeMap = new Map();\n\n            // create the vertices (only done if the array is empty)\n            nodes.forEach((n, i) => {\n                const vertex = {\n                    node: n,\n                    key: n.id\n                    // key: Symbol(n.id).toString()\n                };\n                vertices.push(vertex);\n                this.nodeMap.set(n, vertex);\n            });\n        }\n\n        // update the node locations (vertices)\n        nodes\n            .forEach((n) => {\n                const v = this.nodeMap.get(n);\n\n                v.x = this.tree.rootToTipLength(v.node);\n                currentY = this.setYPosition(v, currentY)\n\n                v.degree = (v.node.children ? v.node.children.length + 1: 1); // the number of edges (including stem)\n\n                v.id = n.id;\n\n                v.classes = [\n                    (!v.node.children ? \"external-node\" : \"internal-node\"),\n                    (v.node.isSelected ? \"selected\" : \"unselected\")];\n\n                if (v.node.annotations) {\n                    v.classes = [\n                        ...v.classes,\n                        ...Object.entries(v.node.annotations)\n                            .filter(([key]) => {\n                                return this.tree.annotations[key] &&\n                                    (this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].DISCRETE ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].BOOLEAN ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].INTEGER);\n                            })\n                            .map(([key, value]) => `${key}-${value}`)];\n                }\n\n                // either the tip name or the internal node label\n                if (v.node.children) {\n                    v.leftLabel = (this.internalNodeLabelAnnotationName?\n                        v.node.annotations[this.internalNodeLabelAnnotationName]:\n                        \"\");\n                    v.rightLabel = \"\";\n\n                    // should the left node label be above or below the node?\n                    v.labelBelow = (!v.node.parent || v.node.parent.children[0] !== v.node);\n                } else {\n                    v.leftLabel = \"\";\n                    v.rightLabel = (this.externalNodeLabelAnnotationName?\n                        v.node.annotations[this.externalNodeLabelAnnotationName]:\n                        v.node.name);\n                }\n\n                this.nodeMap.set(v.node, v);\n            });\n\n        if (edges.length === 0) {\n            this.edgeMap = new Map();\n\n            // create the edges (only done if the array is empty)\n            nodes\n                .filter((n) => n.parent) // exclude the root\n                .forEach((n, i) => {\n                    const edge = {\n                        v0: this.nodeMap.get(n.parent),\n                        v1: this.nodeMap.get(n),\n                        key: n.id\n                        // key: Symbol(n.id).toString()\n                    };\n                    edges.push(edge);\n                    this.edgeMap.set(edge, edge.v1);\n                });\n        }\n\n        // update the edges\n        edges\n            .forEach((e) => {\n                e.v1 = this.edgeMap.get(e);\n                e.v0 = this.nodeMap.get(e.v1.node.parent),\n                    e.classes = [];\n\n                if (e.v1.node.annotations) {\n                    e.classes = [\n                        ...e.classes,\n                        ...Object.entries(e.v1.node.annotations)\n                            .filter(([key]) => {\n                                return this.tree.annotations[key] &&\n                                    (this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].DISCRETE ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].BOOLEAN ||\n                                    this.tree.annotations[key].type === _tree_js__WEBPACK_IMPORTED_MODULE_1__[\"Type\"].INTEGER);\n                            })\n                            .map(([key, value]) => `${key}-${value}`)];\n                }\n                const length = e.v1.x - e.v0.x;\n                e.length = length;\n                e.label = (this.branchLabelAnnotationName ?\n                    (this.branchLabelAnnotationName === 'length' ?\n                        this.settings.lengthFormat(length) :\n                        e.v1.node.annotations[this.branchLabelAnnotationName]) :\n                    null );\n                e.labelBelow = e.v1.node.parent.children[0] !== e.v1.node;\n            });\n    }\n\n    set branchCurve(curve) {\n        this.settings.branchCurve = curve;\n        this.update();\n    }\n\n\n    get branchCurve() {\n        return this.settings.branchCurve;\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setInternalNodeLabels(annotationName) {\n        this.internalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setExternalNodeLabels(annotationName) {\n        this.externalNodeLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n    /**\n     * Sets the annotation to use as the node labels.\n     *\n     * @param annotationName\n     */\n    setBranchLabels(annotationName) {\n        this.branchLabelAnnotationName = annotationName;\n        this.update();\n    }\n\n\n    /**\n     * Updates the tree when it has changed\n     */\n    update() {\n        this.updateCallback();\n    }\n\n    setYPosition(vertex, currentY) {\n        vertex.y = (vertex.node.children ? d3.mean(vertex.node.children, (child) => this.nodeMap.get(child).y) : currentY += 1);\n        return currentY;\n    }\n    branchPathGenerator(scales){\n        const branchPath =(e,i)=>{\n            const branchLine = d3.line()\n                 .x((v) => v.x)\n                .y((v) => v.y)\n                .curve(this.branchCurve);\n            return(\n                branchLine(\n                    [{x: 0, y: scales.y(e.v0.y) - scales.y(e.v1.y)},\n                    {x: scales.x(e.v1.x) - scales.x(e.v0.x), y: 0}]\n                )\n            )\n            \n        }\n        return branchPath;\n    }\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n\n\n//# sourceURL=webpack://figtree/./src/rectangularLayout.js?");

/***/ }),

/***/ "./src/transmissionLayout.js":
/*!***********************************!*\
  !*** ./src/transmissionLayout.js ***!
  \***********************************/
/*! exports provided: Direction, TransmissionLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Direction\", function() { return Direction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TransmissionLayout\", function() { return TransmissionLayout; });\n/* harmony import */ var _rectangularLayout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rectangularLayout.js */ \"./src/rectangularLayout.js\");\n\n\n/** @module layout */\n\n\n\nconst Direction = {\n    UP : Symbol(\"UP\"),\n    DOWN : Symbol(\"DOWN\")\n};\n\n/**\n * The TransmissionLayout class\n *\n */\nclass TransmissionLayout extends _rectangularLayout_js__WEBPACK_IMPORTED_MODULE_0__[\"RectangularLayout\"] {\n\n    /**\n     * The constructor.\n     * @param tree\n     * @param settings\n     */\n    constructor(tree, settings = { }) {\n        super(tree, settings);\n\n        this._direction = Direction.DOWN;\n    }\n\n    /**\n     * Set the direction to draw transmission (up or down).\n     * @param direction\n     */\n    set direction(direction) {\n        this._direction = direction;\n        this.update();\n    }\n\n    /**\n     * Inherited method overwritten to set the y-position of an internal node to the same as its\n     * first child which gives a visual directionality to the tree.\n     * @param vertex\n     * @param currentY\n     * @returns {*}\n     */\n    setYPosition(vertex, currentY) {\n        if (this._direction === Direction.UP) {\n            throw new Error(\"Up direction drawing not implemented yet\");\n        }\n\n        vertex.y = (vertex.node.children ? this.nodeMap.get(vertex.node.children[0]).y : currentY += 1);\n        return currentY;\n    }\n\n}\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n\n\n//# sourceURL=webpack://figtree/./src/transmissionLayout.js?");

/***/ }),

/***/ "./src/tree.js":
/*!*********************!*\
  !*** ./src/tree.js ***!
  \*********************/
/*! exports provided: Type, Tree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Type\", function() { return Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tree\", function() { return Tree; });\n\n\n/** @module tree */\n\nconst Type = {\n    DISCRETE : Symbol(\"DISCRETE\"),\n    BOOLEAN : Symbol(\"BOOLEAN\"),\n    INTEGER : Symbol(\"INTEGER\"),\n    FLOAT: Symbol(\"FLOAT\"),\n    PROBABILITIES: Symbol(\"PROBABILITIES\")\n};\n\n/**\n * The Tree class\n */\nclass Tree {\n    /**\n     * The constructor takes an object for the root node. The tree structure is\n     * defined as nested node objects.\n     *\n     * @constructor\n     * @param {object} rootNode - The root node of the tree as an object.\n     */\n    constructor(rootNode = {}) {\n        this.root = rootNode;\n\n        this.annotations = {};\n\n        this.nodeList = [...this.preorder()];\n        this.nodeList.forEach( (node, index) => {\n            if (node.label && node.label.startsWith(\"#\")) {\n                // an id string has been specified in the newick label.\n                node.id = node.label.substring(1);\n            } else {\n                node.id = `node_${index}`;\n            }\n            this.addAnnotations(node.annotations);\n        });\n        this.nodeMap = new Map(this.nodeList.map( (node) => [node.id, node] ));\n        this.tipMap = new Map(this.externalNodes.map( (tip) => [tip.name, tip] ));\n\n\n        // a callback function that is called whenever the tree is changed\n        this.treeUpdateCallback = () => {};\n    };\n\n    /**\n     * Gets the root node of the Tree\n     *\n     * @returns {Object|*}\n     */\n    get rootNode() {\n        return this.root;\n    };\n\n    /**\n     * Gets an array containing all the node objects\n     *\n     * @returns {*}\n     */\n    get nodes() {\n        return [...this.nodeList];\n    };\n\n    /**\n     * Gets an array containing all the external node objects\n     *\n     * @returns {*}\n     */\n    get externalNodes() {\n        return this.nodes.filter((node) => !node.children);\n    };\n\n    /**\n     * Gets an array containing all the internal node objects\n     *\n     * @returns {*}\n     */\n    get internalNodes() {\n        return this.nodes.filter((node) => node.children );\n    };\n\n    /**\n     * Returns the sibling of a node (i.e., the first other child of the parent)\n     *\n     * @param node\n     * @returns {*}\n     */\n    getSibling(node) {\n        if (!node.parent) {\n            return null;\n        }\n        return node.parent.children.find((child) => child !== node);\n    }\n\n    /**\n     * Returns a node from its id stored.\n     *\n     * @param id\n     * @returns {*}\n     */\n    getNode(id) {\n        return this.nodeMap.get(id);\n    }\n\n    /**\n     * Returns an external node (tip) from its name.\n     *\n     * @param name\n     * @returns {*}\n     */\n    getExternalNode(name) {\n        return this.tipMap.get(name);\n    }\n\n    /**\n     * A generator function that returns the nodes in a pre-order traversal.\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *preorder() {\n        const traverse = function *(node) {\n            yield node;\n            if (node.children) {\n                for (const child of node.children) {\n                    yield* traverse(child);\n                }\n            }\n        };\n\n        yield* traverse(this.root);\n    }\n\n    /**\n     * A generator function that returns the nodes in a post-order traversal\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    *postorder() {\n        const traverse = function *(node) {\n            if (node.children) {\n                for (const child of node.children) {\n                    yield* traverse(child);\n                }\n            }\n            yield node;\n        };\n\n        yield* traverse(this.root);\n    }\n\n    /**\n     * A generator function that returns the nodes in a path to the root\n     *\n     * @returns {IterableIterator<IterableIterator<*|*>>}\n     */\n    static* pathToRoot(node) {\n        while (node) {\n            yield node;\n            node = node.parent;\n        }\n    }\n\n    /**\n     * An instance method to return a Newick format string for the Tree. Can be called without a parameter to\n     * start at the root node. Providing another node will generate a subtree. Labels and branch lengths are\n     * included if available.\n     *\n     * @param {object} node - The node of the tree to be written (defaults as the rootNode).\n     * @returns {string}\n     */\n    toNewick(node = this.rootNode) {\n        return (node.children ? `(${node.children.map(child => this.toNewick(child)).join(\",\")})${node.label ? node.label : \"\"}` : node.name) + (node.length ? `:${node.length}` : \"\");\n    };\n\n    /**\n     * Re-roots the tree at the midway point on the branch above the given node.\n     *\n     * @param {object} node - The node to be rooted on.\n     * @param proportion - proportion along the branch to place the root (default 0.5)\n     */\n    reroot(node, proportion = 0.5) {\n        if (node === this.rootNode) {\n            // the node is the root - nothing to do\n            return;\n        }\n\n        const rootLength = this.rootNode.children[0].length + this.rootNode.children[1].length;\n\n        if (node.parent !== this.rootNode) {\n            // the node is not a child of the existing root so the root is actually changing\n\n            let node0 = node;\n            let parent = node.parent;\n\n            let lineage = [ ];\n\n            // was the node the first child in the parent's children?\n            const nodeAtTop = parent.children[0] === node;\n\n            const rootChild1 = node;\n            const rootChild2 = parent;\n\n            let oldLength = parent.length;\n\n            while (parent.parent) {\n\n                // remove the node that will becoming the parent from the children\n                parent.children = parent.children.filter((child) => child !== node0);\n\n                if (parent.parent === this.rootNode) {\n                    const sibling = this.getSibling(parent);\n                    parent.children.push(sibling);\n                    sibling.length = rootLength;\n                } else {\n                    // swap the parent and parent's parent's length around\n                    [parent.parent.length, oldLength] = [oldLength, parent.parent.length];\n\n                    // add the new child\n                    parent.children.push(parent.parent);\n                }\n\n                lineage = [parent, ...lineage];\n\n                node0 = parent;\n                parent = parent.parent;\n            }\n\n            // Reuse the root node as root...\n\n            // Set the order of the children to be the same as for the original parent of the node.\n            // This makes for a more visually consistent rerooting graphically.\n            this.rootNode.children = nodeAtTop ? [rootChild1, rootChild2] : [rootChild2, rootChild1];\n\n            // connect all the children to their parents\n            this.internalNodes\n                .forEach((node) => {\n                    node.children.forEach((child) => {\n                        child.parent = node;\n                    })\n                });\n\n            const l = rootChild1.length * proportion;\n            rootChild2.length = l;\n            rootChild1.length = rootChild1.length - l;\n\n        } else {\n            // the root is staying the same, just the position of the root changing\n            const l = node.length * (1.0 - proportion);\n            node.length = l;\n            this.getSibling(node).length = rootLength - l;\n        }\n\n        this.treeUpdateCallback();\n    };\n\n    /**\n     * Reverses the order of the children of the given node. If 'recursive=true' then it will\n     * descend down the subtree reversing all the sub nodes.\n     *\n     * @param node\n     * @param recursive\n     */\n    rotate(node, recursive = false) {\n        if (node.children) {\n            if (recursive) {\n                for (const child of node.children) {\n                    this.rotate(child, recursive);\n                }\n            }\n            node.children.reverse();\n        }\n\n        this.treeUpdateCallback();\n    };\n\n    /**\n     * Sorts the child branches of each node in order of increasing or decreasing number\n     * of tips. This operates recursively from the node given.\n     *\n     * @param node - the node to start sorting from\n     * @param {boolean} increasing - sorting in increasing node order or decreasing?\n     * @returns {number} - the number of tips below this node\n     */\n    order(node = this.rootNode, increasing = true) {\n        // orderNodes.call(this, node, increasing, this.treeUpdateCallback);\n        orderNodes.call(this, node, increasing);\n        this.treeUpdateCallback();\n    }\n\n    lastCommonAncestor(node1, node2) {\n\n        const path1 = [...Tree.pathToRoot(node1)];\n        const path2 = [...Tree.pathToRoot(node2)];\n      \n        const sharedAncestors = path1.filter(n1=>path2.map(n2=>n2.id).indexOf(n1.id)>-1);\n        const lastSharedAncestor = sharedAncestors.reduce((acc,curr)=>acc = acc.level>curr.level?acc:curr);\n        return lastSharedAncestor;\n      \n    }\n\n    pathLength(node1, node2) {\n\n        let sum = 0;\n        \n        const mrca = this.lastCommonAncestor(node1,node2);\n        for(let node of [node1,node2]){\n            while(node!=mrca){\n              sum+=node.length;\n              node=node.parent;\n            }\n        }\n        \n        return sum;\n    }\n\n    /**\n     * Gives the distance from the root to a given tip (external node).\n     * @param tip - the external node\n     * @returns {number}\n     */\n    rootToTipLength(tip) {\n        let length = 0.0;\n        for (const node of Tree.pathToRoot(tip)) {\n            if (node.length) {\n                length += node.length;\n            }\n        }\n        return length;\n\n    }\n\n    /**\n     * Returns an array of root-to-tip distances for each tip in the tree.\n     * @returns {*}\n     */\n    rootToTipLengths() {\n        return this.externalNodes.map((tip) => this.rootToTipLength(tip));\n    }\n\n    /**\n     * Splits each branch in multiple segments inserting a new degree 2 nodes. If splitLocations is\n     * null then it splits each in two at the mid-point\n     * @param splits\n     */\n    splitBranches(splits = null) {\n        // split each branch into sections, with a node of\n        // degree two in the middle. This allows annotation\n        // of part of a branch.\n        [...this.preorder()]\n            .filter((node) => node.parent)\n            .forEach((node) => {\n                if (splits !== null) {\n                    if (splits[node.id]) {\n                        let splitNode = node;\n                        splits[node.id].forEach(([time, id]) => {\n                            splitNode = this.splitBranch(splitNode, time);\n                            splitNode.id = id;\n                        })\n                    }\n                } else {\n                    // if no splitLocations are given then split it in the middle.\n                    this.splitBranch(node, node.length / 2.0);\n                }\n            });\n    }\n\n    /**\n     * Splits a branch in two inserting a new degree 2 node. The splitLocation should be less than\n     * the orginal branch length.\n     * @param node\n     * @param splitLocation\n     */\n    splitBranch(node, splitLocation) {\n        const oldLength = node.length;\n\n        let splitNode = {\n            parent: node.parent,\n            children: [node],\n            length: oldLength - splitLocation,\n            annotations: {\n                midpoint: true\n            }\n        };\n        node.parent.children[node.parent.children.indexOf(node)] = splitNode;\n        node.parent = splitNode;\n        node.length = splitLocation;\n\n        return splitNode;\n    }\n\n    /**\n     * Set one or more annotations for the tips.\n     *\n     * See annotateNode for a description of the annotation structure.\n     *\n     * @param annotations a dictionary of annotations keyed by tip label\n     */\n    annotateTips(annotations) {\n        for (let [key, values] of Object.entries(annotations)) {\n            const tip = this.getExternalNode(key);\n            if (!tip) {\n                throw new Error(`tip with label ${key} not found in tree`);\n            }\n\n            this.annotateNode(tip, values);\n        }\n    }\n\n    /**\n     * This is similar to annotateTips but the annotation objects are keyed by node\n     * keys (Symbols).\n     *\n     * @param annotations a dictionary of annotations keyed by node key\n     */\n    annotateNodes(annotations) {\n        for (let [key, values] of Object.entries(annotations)) {\n            const node = this.getNode(key);\n            if (!node) {\n                throw new Error(`tip with key ${key} not found in tree`);\n            }\n\n            this.annotateNode(node, values);\n        }\n    }\n\n    /**\n     * Adds the given annotations to a particular node object.\n     *\n     * The annotations is an object with properties keyed by external node labels each\n     * of which is an object with key value pairs for the annotations. The\n     * key value pairs will be added to a property called 'annotations' in the node.\n     *\n     * Boolean or Numerical traits are given as a single value.\n     * Sets of values with probabilities should be given as an object.\n     * Discrete values should be given as an array (even if containing only one value)\n     * or an object with booleans to give the full set of possible trait values.\n     *\n     * For example:\n     *\n     * {\n     *     'tip_1': {\n     *         'trait_1' : true,\n     *         'trait_4' : 3.141592,\n     *         'trait_2' : [1, 2], // discrete trait\n     *         'trait_3' : [\"London\", \"Paris\", \"New York\"], // discrete trait\n     *         'trait_3' : {\"London\" : true, \"Paris\" : false, \"New York\": false], // discrete trait with full set of values\n     *         'trait_4' : {\"London\" : 0.75, \"Paris\" : 0.20, \"New York\": 0.05} // probability set\n     *     },\n     *     'tip_2': {...}\n     * }\n     *\n     * The annotation labels, type and possible values are also added to the tree in a property called 'annotations'.\n     *\n     * A reconstruction method such as annotateNodesFromTips can then be used to provide reconstructed values\n     * for internal nodes. Or annotateNodes can provide annotations for any node in the tree.\n     *\n     * @param node\n     * @param annotations a dictionary of annotations keyed by the annotation name.\n     */\n    annotateNode(node, annotations) {\n        this.addAnnotations(annotations);\n\n        // add the annotations to the existing annotations object for the node object\n        node.annotations = {...(node.annotations === undefined ? {} : node.annotations), ...annotations};\n    }\n\n    /**\n     * Adds the annotation information to the tree. This stores the type and possible values\n     * for each annotation seen in the nodes of the tree.\n     *\n     * This methods also checks the values are correct and conform to previous annotations\n     * in type.\n     *\n     * @param annotations\n     */\n    addAnnotations(annotations) {\n        for (let [key, addValues] of Object.entries(annotations)) {\n            let annotation = this.annotations[key];\n            if (!annotation) {\n                annotation = {};\n                this.annotations[key] = annotation;\n            }\n\n            if (Array.isArray(addValues)) {\n                // is a set of discrete values\n                const type = Type.DISCRETE;\n\n                if (annotation.type && annotation.type !== type) {\n                    throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n                }\n                annotation.type = type;\n                annotation.values = [...annotation.values, ...addValues];\n            } else if (Object.isExtensible(addValues)) {\n                // is a set of properties with values\n                let type = null;\n\n                let sum = 0.0;\n                let keys = [];\n                for (let [key, value] of Object.entries(addValues)) {\n                    if (keys.includes(key)) {\n                        throw Error(`the states of annotation, ${key}, should be unique`);\n                    }\n                    if (typeof value === typeof 1.0) {\n                        // This is a vector of probabilities of different states\n                        type = (type === undefined) ? Type.PROBABILITIES : type;\n\n                        if (type === Type.DISCRETE) {\n                            throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                        }\n\n                        sum += value;\n                        if (sum > 1.0) {\n                            throw Error(`the values of annotation, ${key}, should be probabilities of states and add to 1.0`);\n                        }\n                    } else if (typeof value === typeof true) {\n                        type = (type === undefined) ? Type.DISCRETE : type;\n\n                        if (type === Type.PROBABILITIES) {\n                            throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                        }\n                    } else {\n                        throw Error(`the values of annotation, ${key}, should be all boolean or all floats`);\n                    }\n                    keys.append(key);\n                }\n\n                if (annotation.type && annotation.type !== type) {\n                    throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n                }\n\n                annotation.type = type;\n                annotation.values = [...annotation.values, ...addValues];\n            } else {\n                let type = Type.DISCRETE;\n\n                if (typeof addValues === typeof true) {\n                    type = Type.BOOLEAN;\n                } else if (Number(addValues)) {\n                    type = (addValues % 1 === 0 ? Type.INTEGER : Type.FLOAT);\n                }\n\n                if (annotation.type && annotation.type !== type) {\n                    if ((type === Type.INTEGER && annotation.type === Type.FLOAT) ||\n                        (type === Type.FLOAT && annotation.type === Type.INTEGER)) {\n                        // upgrade to float\n                        type = Type.FLOAT;\n                    } else {\n                        throw Error(`existing values of the annotation, ${key}, in the tree is not of the same type`);\n                    }\n                }\n\n                if (type === Type.DISCRETE) {\n                    if (!annotation.values) {\n                        annotation.values = new Set();\n                    }\n                    annotation.values.add(addValues);\n                }\n\n                annotation.type = type;\n            }\n\n            // overwrite the existing annotation property\n            this.annotations[key] = annotation;\n        }\n    }\n\n    /**\n     * Uses parsimony to label internal nodes to reconstruct the internal node states\n     * for the annotation 'name'.\n     *\n     * @param name\n     * @param acctrans Use acctrans reconstruction if true, deltrans otherwise\n     * @param node\n     */\n    annotateNodesFromTips(name, acctran = true) {\n        fitchParsimony(name, this.rootNode);\n\n        reconstructInternalStates(name, [], acctran, this.rootNode);\n    }\n\n    /**\n     * A class method to create a Tree instance from a Newick format string (potentially with node\n     * labels and branch lengths). Taxon labels should be quoted (either \" or ') if they contain whitespace\n     * or any of the tree definitition characters '(),:;' - the quotes (and any whitespace immediately within)\n     * will be removed.\n     * @param newickString - the Newick format tree as a string\n     * @param labelName\n     * @param datePrefix\n     * @returns {Tree} - an instance of the Tree class\n     */\n    static parseNewick(newickString, labelName = \"label\", datePrefix = undefined ) {\n        const tokens = newickString.split(/\\s*('[^']+'|\"[^\"]+\"|;|\\(|\\)|,|:)\\s*/);\n\n        let level = 0;\n        let currentNode = null;\n        let nodeStack = [];\n        let labelNext = false;\n        let lengthNext = false;\n\n        for (const token of tokens.filter(token => token.length > 0)) {\n            // console.log(`Token ${i}: ${token}, level: ${level}`);\n            if (token === \"(\") {\n                // an internal node\n\n                if (labelNext) {\n                    // if labelNext is set then the last bracket has just closed\n                    // so there shouldn't be an open bracket.\n                    throw new Error(\"expecting a comma\");\n                }\n\n                let node = {\n                    level: level,\n                    parent: currentNode,\n                    children: [],\n                    annotations: {}\n                };\n                level += 1;\n                if (currentNode) {\n                    nodeStack.push(currentNode);\n                }\n                currentNode = node;\n\n            } else if (token === \",\") {\n                // another branch in an internal node\n\n                labelNext = false; // labels are optional\n                if (lengthNext) {\n                    throw new Error(\"branch length missing\");\n                }\n\n                let parent = nodeStack.pop();\n                parent.children.push(currentNode);\n\n                currentNode = parent;\n            } else if (token === \")\") {\n                // finished an internal node\n\n                labelNext = false; // labels are optional\n                if (lengthNext) {\n                    throw new Error(\"branch length missing\");\n                }\n\n                // the end of an internal node\n                let parent = nodeStack.pop();\n                parent.children.push(currentNode);\n\n                level -= 1;\n                currentNode = parent;\n\n                labelNext = true;\n            } else if (token === \":\") {\n                labelNext = false; // labels are optional\n                lengthNext = true;\n            } else if (token === \";\") {\n                // end of the tree, check that we are back at level 0\n                if (level > 0) {\n                    throw new Error(\"unexpected semi-colon in tree\")\n                }\n                break;\n            } else {\n                // not any specific token so may be a label, a length, or an external node name\n                if (lengthNext) {\n                    currentNode.length = parseFloat(token);\n                    lengthNext = false;\n                } else if (labelNext) {\n                    currentNode.label = token;\n                    if (!currentNode.label.startsWith(\"#\")) {\n                        let value = parseFloat(currentNode.label);\n                        if (isNaN(value)) {\n                            value = currentNode.label;\n                        }\n                        currentNode.annotations[labelName] = value;\n                    } else {\n                        currentNode.id = currentNode.label.substring(1);\n                    }\n                    labelNext = false;\n                } else {\n                    // an external node\n                    if (!currentNode.children) {\n                        currentNode.children = []\n                    }\n\n                    let name = token;\n\n                    // remove any quoting and then trim whitespace\n                    if (name.startsWith(\"\\\"\") || name.startsWith(\"'\")) {\n                        name = name.substr(1);\n                    }\n                    if (name.endsWith(\"\\\"\") || name.endsWith(\"'\")) {\n                        name = name.substr(0, name.length - 1);\n                    }\n                    name = name.trim();\n\n                    let date = undefined;\n                    if (datePrefix) {\n                        const parts = name.split(datePrefix);\n                        if (parts.length === 0) {\n                            throw new Error(`the tip, ${name}, doesn't have a date separated by the prefix, '${datePrefix}'`);\n                        }\n                        date = parseFloat(parts[parts.length - 1]);\n                    }\n\n                    const externalNode = {\n                        name: name,\n                        date: date,\n                        parent: currentNode,\n                        annotations: {}\n                    };\n\n                    if (currentNode) {\n                        nodeStack.push(currentNode);\n                    }\n                    currentNode = externalNode;\n                }\n            }\n        }\n\n        if (level > 0) {\n            throw new Error(\"the brackets in the newick file are not balanced\")\n        }\n\n        return new Tree(currentNode);\n    };\n}\n\n/*\n * Private methods, called by the class using the <function>.call(this) function.\n */\n\n/**\n * A private recursive function that rotates nodes to give an ordering.\n * @param node\n * @param increasing\n * @param callback an optional callback that is called each rotate\n * @returns {number}\n */\nfunction orderNodes(node, increasing, callback = null) {\n    const factor = increasing ? 1 : -1;\n    let count = 0;\n    if (node.children) {\n        const counts = new Map();\n        for (const child of node.children) {\n            const value = orderNodes(child, increasing, callback);\n            counts.set(child, value);\n            count += value;\n        }\n        node.children.sort((a, b) => {\n            return (counts.get(a) - counts.get(b)) * factor\n        });\n\n        if (callback) callback();\n    } else {\n        count = 1\n    }\n    return count;\n}\n\n/**\n * A private recursive function that uses the Fitch algorithm to assign\n * states to nodes using parsimony. An acctrans or deltrans algorithm can\n * then be used to reconstruct internal node states.\n * @param name\n * @param node\n * @returns {*}\n */\nfunction fitchParsimony(name, node) {\n\n    if (!node.children) {\n        if (!node.annotations[name]) {\n            return []; // annotation not defined so return an empty set\n        }\n        return (Array.isArray(node.annotations[name]) ? node.annotations[name] : [node.annotations[name]]);\n    }\n\n    let I;\n    let U = [];\n    node.children.forEach( (child) => {\n        const childStates = fitchParsimony(name, child);\n        U = [...U, ...childStates.filter( (state) => !U.includes(state) )]; // take the union\n        I = (I === undefined ? childStates : childStates.filter( (state) => I.includes(state) )); // take the intersection\n    });\n\n    node.annotations = (node.annotations === undefined ? {} : node.annotations);\n\n    // set the node annotation to the intersection if not empty, the union otherwise\n    node.annotations[name] = [...(I.length > 0 ? I : U)];\n\n    return node.annotations[name];\n}\n\nfunction reconstructInternalStates(name, parentStates, acctran, node ) {\n    let nodeStates = node.annotations[name];\n    if (!Array.isArray(nodeStates)) {\n        nodeStates = [nodeStates];\n    }\n\n    if (node.children) {\n\n        let stateCounts = {};\n\n        nodeStates\n            .forEach((state) => stateCounts[state] = (stateCounts[state] ? stateCounts[state] += 1 : 1) );\n\n        parentStates\n            .forEach((state) => stateCounts[state] = (stateCounts[state] ? stateCounts[state] += 1 : 1) );\n\n        node.children.forEach((child) => {\n            reconstructInternalStates(name, nodeStates, acctran, child)\n                .forEach((state) => stateCounts[state] = (stateCounts[state] ? stateCounts[state] += 1 : 1) );\n        });\n\n        const max = Object.entries(stateCounts).reduce((prev, current) => (prev[1] > current[1]) ? prev : current)[1];\n        nodeStates = Object.entries(stateCounts).filter(([state, count]) => count === max).map(([state, count]) => state );\n\n        node.annotations[name] = (nodeStates.length === 1 ? nodeStates[0] : nodeStates);\n    }\n\n    return nodeStates;\n}\n\n//# sourceURL=webpack://figtree/./src/tree.js?");

/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_d3__;\n\n//# sourceURL=webpack://figtree/external_%22d3%22?");

/***/ })

/******/ });
});